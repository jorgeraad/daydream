# Design Doc: Logging System

| Field              | Value |
|--------------------|-------|
| **Created**        | 2026-02-12 16:47:37 EST |
| **Last Modified**  | 2026-02-12 16:47:37 EST |
| **Status**         | draft |
| **Author**         | steady-marten |
| **Task**           | — |
| **References**     | [Design Doc](../design.md) (Section 12), [PRD](../prd.md) |

---

## 1. Overview

### Problem

The Daydream codebase has virtually no logging. The only output is `main().catch(console.error)` at the top level. This causes several concrete problems:

- **Silent failures**: World generation errors fall back to a test zone without any notification to the developer or player. The `catch` block at `index.ts:552` discards the error entirely.
- **AI opacity**: No visibility into Claude API calls — model selection, token usage, latency, prompt content, and response parsing are all invisible.
- **Event flow blindness**: The EventBus handles all cross-system communication but doesn't log emissions or subscriptions, making it impossible to trace game behavior.
- **No debugging support**: When something breaks, there's no trail to follow. State mutations, mode changes, zone transitions — all unrecorded.
- **TUI constraint**: Since OpenTUI uses alternate screen mode, `console.log` during gameplay is invisible. Even if someone adds logging, it won't be seen.

### Solution

A structured logging system built on [LogTape](https://logtape.org/) that:

1. **Writes to rotating log files** at `~/.daydream/logs/` — the only reliable destination during TUI gameplay
2. **Uses hierarchical categories** matching the monorepo package structure for per-module control
3. **Instruments key systems** — AI calls, EventBus, WorldState, error boundaries
4. **Is configurable** via in-game settings, settings file, and environment variables
5. **Supports structured data** — attach context (zone IDs, token counts, durations) to every log message

### Scope

**In scope:**
- LogTape integration and configuration
- File sink with rotation at `~/.daydream/logs/`
- Configurable log level and format (text/JSON)
- In-game settings UI for log level and format
- Environment variable overrides
- Category conventions for all 4 packages
- AI call instrumentation (timing, tokens, full prompts at debug)
- EventBus trace logging
- Error handling improvements (replace silent catches)

**Out of scope (future work):**
- In-game debug panel / log viewer overlay
- Remote log shipping (cloud, Sentry, OpenTelemetry)
- Performance metrics / profiling framework
- Log analysis tooling

---

## 2. Why LogTape

### Library Comparison

| | **LogTape** | **pino** | **winston** | **Custom** |
|---|---|---|---|---|
| **Dependencies** | 0 | Many (worker threads) | Many | 0 |
| **Size** | 5.3KB | ~50KB+ | ~200KB+ | Varies |
| **Bun support** | Native, designed for it | Needs `bun-plugin-pino` | Works, heavy | Native |
| **TypeScript** | Written in TS | Has types | Has types | Written in TS |
| **Structured logging** | Message templates + properties | JSON-native | Custom formatters | Whatever we build |
| **Hierarchical loggers** | Category arrays, sink inheritance | Child loggers (imperative) | Nested loggers | Whatever we build |
| **File sink** | Built-in with rotation | Via transports | Via transports | Must implement |
| **Non-blocking mode** | Built-in | Worker threads | Async hooks | Must implement |

### Why LogTape Wins

1. **Zero dependencies** — aligns with project minimalism. No worker threads, no plugins.
2. **Hierarchical categories as arrays** — `["daydream", "ai", "client"]` maps perfectly to our package structure. Sinks and levels are inherited: configuring `["daydream", "ai"]` automatically applies to all AI sub-loggers.
3. **Built-in file sink with rotation** — `@logtape/file` provides size-based and time-based rotation, buffering, and non-blocking mode out of the box.
4. **Structured logging** — `logger.info("Zone {zoneId} generated in {ms}ms", { zoneId, ms })` embeds data in both the human-readable message and the structured properties.
5. **Central configuration** — `configure()` once at startup, `getLogger()` anywhere. No shared package needed.
6. **Tiny footprint** — 5.3KB won't impact game startup or bundle size.

---

## 3. Architecture

### 3.1 System Placement

```
@daydream/game (apps/game)
└── src/logging/
    └── configure.ts    — configureLogging(): reads settings + env, calls LogTape configure()

All packages:
  import { getLogger } from "@logtape/logtape";
  const logger = getLogger(["daydream", "<package>", "<module>"]);
```

There is **no `@daydream/logger` package**. Each package imports `getLogger` directly from `@logtape/logtape` (added to the Bun catalog). The game app is the only place that calls `configure()` — it reads settings, applies environment overrides, and sets up sinks.

This works because LogTape's `getLogger()` is a global registry. Any package can call it at any time; messages are routed to whatever sinks were configured at startup. If `configure()` hasn't been called yet (e.g., during tests), log messages are silently dropped — no errors.

### 3.2 Data Flow

```
Any module                  Game startup
    │                           │
    ▼                           ▼
getLogger(["daydream", ...])   configureLogging(settings)
    │                           │
    ▼                           ▼
logger.info("msg", {data})     configure({
    │                             sinks: { file, console? },
    │                             loggers: [{ category, level, sinks }]
    │                           })
    │                           │
    ▼                           ▼
LogTape internal routing ◄─── Sink + level config
    │
    ├──► File sink ──► ~/.daydream/logs/daydream.log
    │                  (rotating, buffered, non-blocking)
    │
    └──► Console sink ──► stderr (only when LOG_CONSOLE=1, for tests/dev)
```

### 3.3 Category Hierarchy

Categories use the pattern `["daydream", "<package>", "<module>"]`. This enables controlling verbosity at any granularity — entire packages, specific modules, or even specific concerns.

```
["daydream"]                          # Root — catches everything
├── ["daydream", "engine"]            # Engine package
│   ├── ["daydream", "engine", "world"]       # WorldState, Zone, ZoneBuilder
│   ├── ["daydream", "engine", "event"]       # EventBus, EventSystem, WorldTicker
│   ├── ["daydream", "engine", "chronicle"]   # Chronicle, NarrativeThread
│   └── ["daydream", "engine", "character"]   # Character, CharacterMemory
├── ["daydream", "ai"]                # AI package
│   ├── ["daydream", "ai", "client"]          # AIClient (calls, timing, tokens)
│   ├── ["daydream", "ai", "context"]         # ContextManager (budget, assembly)
│   └── ["daydream", "ai", "prompts"]         # Prompt builders
├── ["daydream", "renderer"]          # Renderer package
│   ├── ["daydream", "renderer", "tile"]      # TileRenderer
│   ├── ["daydream", "renderer", "viewport"]  # ViewportManager
│   └── ["daydream", "renderer", "ui"]        # UI components
└── ["daydream", "game"]              # Game app
    ├── ["daydream", "game", "input"]         # InputRouter
    ├── ["daydream", "game", "dialogue"]      # DialogueManager
    ├── ["daydream", "game", "world-gen"]     # WorldGenerator
    └── ["daydream", "game", "settings"]      # SettingsManager
```

**Usage in a module:**

```typescript
// packages/ai/src/client.ts
import { getLogger } from "@logtape/logtape";

const logger = getLogger(["daydream", "ai", "client"]);

export class AIClient {
  async generate(params: GenerateParams): Promise<AIResponse> {
    const start = performance.now();
    logger.debug("AI request: {task} via {model}", {
      task: params.taskType,
      model: modelId,
      system: params.system,       // Full prompt at debug level
      messages: params.messages,
    });

    const response = await this.client.messages.create(/* ... */);
    const parsed = this.parseResponse(response);
    const duration = Math.round(performance.now() - start);

    logger.info("AI call: {task} ({model}) — {duration}ms, {inputTokens}in/{outputTokens}out", {
      task: params.taskType,
      model: modelId,
      duration,
      inputTokens: parsed.usage.inputTokens,
      outputTokens: parsed.usage.outputTokens,
    });

    return parsed;
  }
}
```

---

## 4. Configuration

### 4.1 Configuration Layers

Configuration is resolved in priority order (highest wins):

```
Environment variables  (LOG_LEVEL, LOG_FORMAT, LOG_FILE)
        ▼ overrides
Settings file          (~/.daydream/settings.json → logging section)
        ▼ overrides
Defaults               (level: "info", format: "text")
```

### 4.2 Defaults

| Setting | Default | Description |
|---------|---------|-------------|
| `level` | `"info"` | Minimum severity: `trace`, `debug`, `info`, `warning`, `error`, `fatal` |
| `format` | `"text"` | Log format: `"text"` (human-readable) or `"json"` (JSON Lines) |
| `filePath` | `"~/.daydream/logs/daydream.log"` | Log file location |
| `maxFileSize` | `5_242_880` (5 MB) | Size before rotation |
| `maxFiles` | `5` | Number of rotated files to keep (25 MB total max) |

### 4.3 Environment Variables

| Variable | Example | Description |
|----------|---------|-------------|
| `LOG_LEVEL` | `LOG_LEVEL=debug` | Override global log level |
| `LOG_FORMAT` | `LOG_FORMAT=json` | Override format (`text` or `json`) |
| `LOG_FILE` | `LOG_FILE=/tmp/daydream.log` | Override log file path |
| `LOG_CONSOLE` | `LOG_CONSOLE=1` | Also write to stderr (for development/tests) |
| `LOG_FILTER` | `LOG_FILTER=ai=debug,renderer=warn` | Per-category level overrides |

`LOG_FILTER` syntax: comma-separated `category=level` pairs. Category names use dots: `ai.client=debug` maps to `["daydream", "ai", "client"]`.

### 4.4 Settings File

The existing `~/.daydream/settings.json` gains a `logging` section:

```json
{
  "logging": {
    "level": "info",
    "format": "text"
  }
}
```

SettingsManager already handles reading/writing this file. The logging config is read at startup and written when changed via the in-game settings screen.

### 4.5 In-Game Settings UI

The existing Settings screen (`SettingsScreen.ts`) gains a "Logging" section with two options:

```
╔══════════════════════════════════════╗
║            ⚙ Settings                ║
╠══════════════════════════════════════╣
║                                      ║
║  API Keys                            ║
║  ├─ Anthropic: sk-ant-...Xk4Q  ✓    ║
║                                      ║
║  Logging                             ║
║  ├─ Level: [info ▾]                  ║
║  │    trace · debug · info ·         ║
║  │    warning · error · fatal        ║
║  ├─ Format: [text ▾]                 ║
║  │    text · json                    ║
║                                      ║
║  Log files: ~/.daydream/logs/        ║
║                                      ║
╚══════════════════════════════════════╝
```

**Level changes take effect immediately** — the configure function is re-called when the setting changes, updating all logger thresholds without restarting the game. LogTape's `configure()` with `reset: true` supports this.

### 4.6 Configuration Module

```typescript
// apps/game/src/logging/configure.ts
import { configure, type LogLevel } from "@logtape/logtape";
import { getRotatingFileSink } from "@logtape/file";
import { getConsoleSink } from "@logtape/logtape";
import { join } from "node:path";
import { homedir } from "node:os";
import { mkdirSync } from "node:fs";

export interface LoggingConfig {
  level: LogLevel;
  format: "text" | "json";
  filePath?: string;
  maxFileSize?: number;
  maxFiles?: number;
  console?: boolean;
  filters?: Record<string, LogLevel>;  // category.path → level
}

const DEFAULTS: Required<LoggingConfig> = {
  level: "info",
  format: "text",
  filePath: join(homedir(), ".daydream", "logs", "daydream.log"),
  maxFileSize: 5_242_880,  // 5 MB
  maxFiles: 5,
  console: false,
  filters: {},
};

export async function configureLogging(userConfig?: Partial<LoggingConfig>): Promise<void> {
  const envConfig = readEnvConfig();
  const config = { ...DEFAULTS, ...userConfig, ...envConfig };

  // Ensure log directory exists
  const logDir = config.filePath.substring(0, config.filePath.lastIndexOf("/"));
  mkdirSync(logDir, { recursive: true });

  // Build sinks
  const sinks: Record<string, unknown> = {
    file: getRotatingFileSink(config.filePath, {
      maxSize: config.maxFileSize,
      maxFiles: config.maxFiles,
      formatter: config.format === "json" ? jsonLinesFormatter : textFormatter,
    }),
  };

  if (config.console) {
    sinks.console = getConsoleSink({ formatter: textConsoleFormatter });
  }

  // Build logger configs
  const loggers = [
    {
      category: ["daydream"],
      lowestLevel: config.level,
      sinks: Object.keys(sinks),
    },
  ];

  // Apply per-category filters from LOG_FILTER
  for (const [categoryPath, level] of Object.entries(config.filters)) {
    const category = ["daydream", ...categoryPath.split(".")];
    loggers.push({
      category,
      lowestLevel: level,
      sinks: Object.keys(sinks),
    });
  }

  await configure({ sinks, loggers, reset: true });
}

function readEnvConfig(): Partial<LoggingConfig> {
  const config: Partial<LoggingConfig> = {};

  if (process.env.LOG_LEVEL) {
    config.level = process.env.LOG_LEVEL as LogLevel;
  }
  if (process.env.LOG_FORMAT) {
    config.format = process.env.LOG_FORMAT as "text" | "json";
  }
  if (process.env.LOG_FILE) {
    config.filePath = process.env.LOG_FILE;
  }
  if (process.env.LOG_CONSOLE === "1") {
    config.console = true;
  }
  if (process.env.LOG_FILTER) {
    config.filters = {};
    for (const pair of process.env.LOG_FILTER.split(",")) {
      const [cat, lvl] = pair.trim().split("=");
      if (cat && lvl) config.filters[cat] = lvl as LogLevel;
    }
  }

  return config;
}
```

### 4.7 Formatters

**Text format** (default) — human-readable, good for `tail -f`:

```
2026-02-12 16:30:52.123 [INFO]  daydream.ai.client: AI call: zone_generation (claude-sonnet-4-5-20250929) — 2340ms, 3200in/1800out
2026-02-12 16:30:52.456 [WARN]  daydream.game.world-gen: Zone generation retry after API timeout {attempt: 2, zoneId: "zone_1_0"}
2026-02-12 16:30:53.789 [ERROR] daydream.ai.client: AI call failed {task: "zone_generation", error: "rate_limit_exceeded", duration: 1200}
```

**JSON Lines format** — machine-parseable, great for `jq`:

```json
{"ts":"2026-02-12T21:30:52.123Z","level":"info","cat":"daydream.ai.client","msg":"AI call: zone_generation (claude-sonnet-4-5-20250929) — 2340ms, 3200in/1800out","task":"zone_generation","model":"claude-sonnet-4-5-20250929","duration":2340,"inputTokens":3200,"outputTokens":1800}
```

Filtering JSON logs:
```bash
# Show only AI errors
cat ~/.daydream/logs/daydream.log | jq 'select(.cat | startswith("daydream.ai")) | select(.level == "error")'

# Show all logs with token counts
cat ~/.daydream/logs/daydream.log | jq 'select(.inputTokens)'
```

---

## 5. Integration Points

### 5.1 AI Client Instrumentation

The highest-value integration. Every AI call gets logged with timing, tokens, and (at debug level) full prompts.

```typescript
// packages/ai/src/client.ts
import { getLogger } from "@logtape/logtape";

const logger = getLogger(["daydream", "ai", "client"]);

export class AIClient {
  async generate(params: GenerateParams): Promise<AIResponse> {
    const modelTier = params.model ?? this.defaultModel;
    const modelId = MODEL_IDS[modelTier];
    const start = performance.now();

    // Debug: full request content
    logger.debug("AI request {task} via {model}", {
      task: params.taskType ?? "unknown",
      model: modelId,
      system: params.system,
      messages: params.messages,
      tools: params.tools?.map(t => t.name),
      temperature: params.temperature,
      maxTokens: params.maxTokens,
    });

    try {
      const response = await this.client.messages.create({ /* ... */ });
      const parsed = this.parseResponse(response);
      const duration = Math.round(performance.now() - start);

      // Info: call summary
      logger.info("AI call {task} ({model}) — {duration}ms, {inputTokens}in/{outputTokens}out", {
        task: params.taskType ?? "unknown",
        model: modelId,
        duration,
        inputTokens: parsed.usage.inputTokens,
        outputTokens: parsed.usage.outputTokens,
        stopReason: parsed.stopReason,
      });

      // Debug: full response content
      logger.debug("AI response for {task}", {
        task: params.taskType ?? "unknown",
        text: parsed.text,
        toolUse: parsed.toolUse,
      });

      return parsed;
    } catch (err) {
      const duration = Math.round(performance.now() - start);
      logger.error("AI call failed for {task} ({model}) after {duration}ms", {
        task: params.taskType ?? "unknown",
        model: modelId,
        duration,
        error: err instanceof Error ? err.message : String(err),
      });
      throw err;
    }
  }
}
```

### 5.2 EventBus Trace Logging

Log all event emissions at trace level. This creates a complete audit trail of game behavior without impacting performance (trace is filtered out at info level).

```typescript
// packages/engine/src/event/EventSystem.ts
import { getLogger } from "@logtape/logtape";

const logger = getLogger(["daydream", "engine", "event"]);

export class EventBus {
  emit<T extends keyof GameEvents>(event: T, data: GameEvents[T]): void {
    logger.trace("Event {event} emitted ({listenerCount} listeners)", {
      event,
      listenerCount: this.listenerCount(event),
      data,
    });
    // ... existing dispatch logic
  }
}
```

### 5.3 Error Handling: World Generation

Replace the silent catch with proper logging and user feedback:

```typescript
// apps/game/src/index.ts
import { getLogger } from "@logtape/logtape";

const logger = getLogger(["daydream", "game", "world-gen"]);

try {
  const world = await generator.generate(playerPrompt, (status) => {
    loadingScreen.setStatus(status);
  });
  // ... success path
} catch (err) {
  logger.error("World generation failed, falling back to test zone", {
    prompt: playerPrompt,
    error: err instanceof Error ? err.message : String(err),
    stack: err instanceof Error ? err.stack : undefined,
  });

  loadingScreen.setStatus("Generation failed — loading demo world...");
  await new Promise(resolve => setTimeout(resolve, 1500));  // Brief pause for user to see message
  loadingScreen.destroy();

  zone = buildTestZone();
  characters = buildTestCharacters(zone);
  spawnX = 5;
  spawnY = 10;
}
```

### 5.4 Game Lifecycle Events

Key moments in the game loop:

```typescript
// apps/game/src/index.ts
const logger = getLogger(["daydream", "game"]);

// Startup
logger.info("Daydream starting");

// After settings loaded
logger.info("Settings loaded, API key {status}", {
  status: settingsManager.hasApiKey("anthropic") ? "configured" : "missing",
});

// World generation start
logger.info("Generating world from prompt: {prompt}", { prompt: playerPrompt });

// Gameplay start
logger.info("Gameplay started in zone {zoneId} at ({x}, {y})", {
  zoneId: zone.id,
  x: spawnX,
  y: spawnY,
  characterCount: characters.length,
});
```

### 5.5 DialogueManager

```typescript
// apps/game/src/DialogueManager.ts
const logger = getLogger(["daydream", "game", "dialogue"]);

async startConversation(characterId: string): Promise<void> {
  const character = this.worldState.characters.get(characterId);
  logger.info("Conversation started with {name} ({id})", {
    name: character?.identity.name,
    id: characterId,
    zone: character?.state.currentZone,
  });
  // ...
}

async endConversation(): Promise<void> {
  logger.info("Conversation ended with {name} after {turns} turns", {
    name: this.currentCharacter?.identity.name,
    turns: this.turnCount,
  });
}
```

### 5.6 Startup Wiring

```typescript
// apps/game/src/index.ts
import { configureLogging } from "./logging/configure.ts";

async function main() {
  // Configure logging FIRST — before anything else
  const settingsManager = new SettingsManager();
  settingsManager.load();

  await configureLogging({
    level: settingsManager.get("logging.level") ?? "info",
    format: settingsManager.get("logging.format") ?? "text",
  });

  const logger = getLogger(["daydream", "game"]);
  logger.info("Daydream starting");

  const renderer = await createCliRenderer({ /* ... */ });
  // ... rest of startup
}
```

---

## 6. SettingsManager Changes

### 6.1 Generic Settings Access

SettingsManager currently only handles API keys. It needs generic get/set for the logging section:

```typescript
export class SettingsManager {
  // Existing: credentials management
  // New: generic settings access

  get<T = unknown>(key: string): T | undefined {
    const parts = key.split(".");
    let current: unknown = this.settings;
    for (const part of parts) {
      if (current == null || typeof current !== "object") return undefined;
      current = (current as Record<string, unknown>)[part];
    }
    return current as T;
  }

  set(key: string, value: unknown): void {
    const parts = key.split(".");
    let current: Record<string, unknown> = this.settings;
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i]!;
      if (!(part in current) || typeof current[part] !== "object") {
        current[part] = {};
      }
      current = current[part] as Record<string, unknown>;
    }
    current[parts[parts.length - 1]!] = value;
    this.writeSettings();
  }

  private writeSettings(): void {
    writeFileSync(this.settingsPath, JSON.stringify(this.settings, null, 2));
  }
}
```

### 6.2 Settings Screen: Logging Section

The SettingsScreen gains a "Logging" section with dropdown-style selection for level and format. When the user changes a value:

1. `settingsManager.set("logging.level", newLevel)` persists it
2. `configureLogging(...)` is re-called with the new settings
3. All loggers immediately use the new level — no restart needed

---

## 7. Performance

### 7.1 Overhead Budget

The game runs at 15 fps target (67ms per frame). Logging must add negligible overhead.

| Operation | Cost | Frequency | Impact |
|-----------|------|-----------|--------|
| `getLogger()` call | < 0.01ms (cached) | Once per module load | None |
| `logger.info()` (above threshold) | ~0.05ms | 1-5 per second | Negligible |
| `logger.trace()` (below threshold) | ~0.001ms (short-circuits) | Could be many | None |
| File sink write (buffered) | Batched async | Every 5s or 8KB | None on game loop |
| Log formatting | ~0.1ms per message | 1-5 per second | Negligible |

### 7.2 Key Performance Strategies

1. **Level-gated short-circuiting**: LogTape checks the level before formatting. A `logger.trace()` call at info level doesn't build the message string or serialize properties.
2. **Non-blocking file sink**: `getRotatingFileSink()` with buffering — log messages are buffered in memory and flushed asynchronously every 5 seconds (or when the buffer fills 8KB). The game loop never waits on disk I/O.
3. **No logging in the render hot path**: TileRenderer's per-cell loop (800 cells/frame) should never contain log calls. Logging belongs at the frame level, not the cell level.
4. **Structured data is lazy**: Properties objects are only serialized when the message actually passes the level filter.

### 7.3 What NOT to Log

To prevent performance issues and log bloat:

- **Never** log inside TileRenderer's per-cell loop
- **Never** log on every player movement (use trace level at most, and only for zone transitions)
- **Never** log full zone tile data (thousands of elements)
- **Avoid** logging in animation update loops
- **Be careful** with trace-level EventBus logging during high-frequency events like `player:moved`

---

## 8. Testing

### 8.1 Testing Strategy

LogTape's `configure()` is global, which means tests need to either:
- Call `configure()` with a test-specific sink in `beforeAll`
- Use `configure({ reset: true })` in `afterAll` to clean up

**Test helper:**

```typescript
// packages/engine/src/__tests__/helpers.ts
import { configure } from "@logtape/logtape";

export function setupTestLogging() {
  const logs: { level: string; category: string[]; message: string; properties: Record<string, unknown> }[] = [];

  const testSink = (record: LogRecord) => {
    logs.push({
      level: record.level,
      category: record.category,
      message: record.message.map(m => typeof m === "string" ? m : JSON.stringify(m)).join(""),
      properties: record.properties,
    });
  };

  beforeAll(async () => {
    await configure({
      sinks: { test: testSink },
      loggers: [{ category: ["daydream"], lowestLevel: "trace", sinks: ["test"] }],
      reset: true,
    });
  });

  afterAll(async () => {
    await configure({ sinks: {}, loggers: [], reset: true });
  });

  return { getLogs: () => logs, clearLogs: () => logs.length = 0 };
}
```

### 8.2 What to Test

- **Configuration module**: Verify env var precedence, settings file reading, default fallbacks
- **Formatter output**: Verify text and JSON formatters produce expected format
- **AI instrumentation**: Verify timing, token counts, and prompt content appear in logs at correct levels
- **SettingsManager changes**: Verify get/set for nested keys, settings file persistence

---

## 9. Implementation Plan

### Task Breakdown

| # | Task | Files | Depends On |
|---|------|-------|------------|
| 1 | Add LogTape to dependency catalog | `package.json` (root), each package `package.json` | — |
| 2 | Configuration module | `apps/game/src/logging/configure.ts` | #1 |
| 3 | Text and JSON formatters | `apps/game/src/logging/formatters.ts` | #1 |
| 4 | SettingsManager: generic get/set | `apps/game/src/settings/SettingsManager.ts` | — |
| 5 | SettingsScreen: logging section | `apps/game/src/settings/SettingsScreen.ts` | #4 |
| 6 | Startup wiring | `apps/game/src/index.ts` | #2, #4 |
| 7 | AI client instrumentation | `packages/ai/src/client.ts` | #1 |
| 8 | EventBus trace logging | `packages/engine/src/event/EventSystem.ts` | #1 |
| 9 | Error handling fixes | `apps/game/src/index.ts`, `apps/game/src/WorldGenerator.ts` | #1, #6 |
| 10 | Game lifecycle logging | `apps/game/src/index.ts`, `apps/game/src/DialogueManager.ts` | #1, #6 |
| 11 | Test helpers and tests | `packages/*/src/__tests__/` | #2, #3 |

### Parallelization

```
#1 (deps) ─┬─ #2 (configure) ─┬─ #6 (startup wiring) ─── #9 (error fixes)
            ├─ #3 (formatters) ─┘                          #10 (lifecycle logging)
            ├─ #7 (AI client) ──────────────────────────── (independent)
            ├─ #8 (EventBus) ───────────────────────────── (independent)
            └─ #11 (tests) ─────────────────────────────── (alongside)

#4 (settings get/set) ── #5 (settings UI) ── #6 (startup wiring)
```

Tasks 4, 7, 8 can run in parallel after #1. Task 6 integrates configuration + settings. Tasks 9-10 add logging calls throughout the codebase.

---

## Appendix A: Why Not a Wrapper Package

**Decision:** Each package imports `@logtape/logtape` directly. No `@daydream/logger` wrapper.

**Options considered:**

1. **New `@daydream/logger` package.** A thin wrapper providing category constants, pre-configured loggers, and helper utilities.
   - Pro: Centralized category names prevent typos. Could add Daydream-specific helpers.
   - Con: Another package in the monorepo. All 4 packages depend on it. Category names are simple string arrays — typos are caught by usage patterns, not types.

2. **Direct imports (chosen).** Add `@logtape/logtape` to the catalog. Each package calls `getLogger()` with its category array. Game app calls `configure()`.
   - Pro: Simplest possible approach. No new package. No wrapper code to maintain. LogTape's API is already clean.
   - Con: Category names are convention-based, not enforced by types. Nothing prevents someone from writing `["daydrem", "ai"]`.

**Rationale:** A wrapper package adds complexity for minimal benefit. Category names are documented in this design doc and are a simple convention. If category name drift becomes a problem in practice, we can add a constants file later — but YAGNI applies here.

## Appendix B: Log Level Guidance

How to choose the right level for a log message:

| Level | When to use | Examples |
|-------|-------------|---------|
| **trace** | Extremely detailed flow tracing. Only useful when debugging a specific issue. | EventBus emissions, per-frame state, loop iterations |
| **debug** | Information useful when diagnosing problems. Full request/response content. | AI prompts/responses, zone build details, state mutations |
| **info** | Normal operational events. Things you'd want to see in a production log. | AI call summaries, game start/stop, zone entered, conversation start/end, settings changed |
| **warning** | Unexpected but recoverable situations. | API retry, missing optional data, deprecated usage, performance threshold exceeded |
| **error** | Operation failure that impacts functionality but not the whole app. | AI call failed, save failed, zone generation error |
| **fatal** | Application-level crash. Something so broken the game can't continue. | Missing required config, unrecoverable state corruption |

## Appendix C: File Sink Rotation Strategy

**Decision:** Size-based rotation at 5 MB, keeping 5 files (25 MB total max).

**Options considered:**

1. **Time-based rotation (daily).** One file per day.
   - Pro: Easy to find "yesterday's logs." Files have predictable names.
   - Con: A heavy debug session could produce a 50+ MB file in one day. Most sessions are short; daily files waste disk with near-empty files.

2. **Size-based rotation at 5 MB, keep 5 (chosen).** Files named `daydream.log`, `daydream.log.1`, ..., `daydream.log.4`.
   - Pro: Bounded disk usage (25 MB max). Files are always a manageable size. Works well for both quick sessions and long debug sessions.
   - Con: Harder to correlate with calendar dates. A long debug session might rotate through all files.

3. **No rotation.** Single file, grows forever.
   - Pro: Simplest.
   - Con: Unbounded disk usage. Must manually clean up.

**Rationale:** 25 MB is generous enough to retain several sessions of debug-level logs but small enough to never surprise someone with disk usage. Size-based rotation handles both casual players (who might log a few KB per session) and developers doing heavy debugging (who might generate MB of AI prompt logs at debug level). The `maxFiles: 5` limit prevents unbounded growth.

## Appendix D: Console Sink Considerations

**Decision:** Console sink disabled by default, enabled via `LOG_CONSOLE=1`.

During gameplay, OpenTUI owns the terminal via alternate screen mode. Writing to stdout would either:
- Be invisible (alternate screen discards it)
- Corrupt the TUI layout (if stdout is shared)

Writing to stderr *might* work in some terminals (alternate screen only captures stdout), but it's unreliable and would produce visual garbage in most setups.

The console sink is useful in two scenarios:
1. **Running tests**: No TUI, console output works normally
2. **Redirected stderr**: `LOG_CONSOLE=1 bun run dev 2>debug.log` — stderr goes to a separate file while the TUI renders normally on stdout

For day-to-day development, `tail -f ~/.daydream/logs/daydream.log` in a separate terminal is the recommended workflow.
