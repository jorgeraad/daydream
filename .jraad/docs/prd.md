# Daydream - Product Requirements Document

## 1. Vision

Daydream is an AI-native terminal game where every world is generated from a single prompt. The player describes where they want to go - "a haunted fishing village," "a floating city in the clouds," "a busy medieval market" - and the AI builds it. As the player explores, the world fills in around them: buildings materialize, characters appear with personalities and backstories, and nature grows according to the biome's logic.

The AI isn't a feature bolted onto a game engine. It **is** the game engine. It decides what characters say, what events unfold, how the world reacts to the player's choices. Every conversation, every action, every passing minute feeds into a living chronicle that shapes what happens next.

The game runs entirely in the terminal, rendered with Unicode art, half-block characters, and rich ANSI colors through the OpenTUI framework. The terminal is the canvas - constrained, evocative, and retro in a different way than pixel art. Think Dwarf Fortress meets AI-generated narrative, rendered beautifully in your terminal.

The result is a game where no two playthroughs are alike, worlds persist and evolve, and the player's choices ripple through a narrative that writes itself.

---

## 2. Core Concepts

### 2.1 The World Seed

Every world begins with a player prompt. This prompt becomes the **world seed** - a natural language description that the AI uses to establish:

- **Biome/setting** (forest, desert, underwater city, space station, etc.)
- **Tone** (dark, whimsical, mysterious, chaotic, peaceful)
- **Era/tech level** (medieval, futuristic, stone age, modern, fantasy-mixed)
- **Initial tension** (what's the conflict? what's interesting here?)

The seed generates an initial world state: terrain, a starting area with a few buildings and characters, and a set of latent narrative threads the AI will develop over time.

### 2.2 The Chronicle

The chronicle is the persistent memory of the world. It records:

- Every conversation the player has (summarized for context efficiency)
- Every event that occurs (weather changes, character arrivals/departures, conflicts)
- Every player action (where they went, what they chose, who they helped or harmed)
- World state changes (buildings constructed/destroyed, territories shifting)

The chronicle serves as the AI's long-term memory. When generating dialogue, events, or world changes, the AI receives relevant portions of the chronicle as context. This is what makes the world feel coherent and responsive - a character you insulted three hours ago remembers it.

**Chronicle compression**: Raw logs are periodically summarized by the AI into condensed narrative summaries. This keeps the context window manageable while preserving the important threads.

### 2.3 The World Graph

The world is represented as an interconnected graph of **zones**. Each zone is a screen-sized tile map rendered in the terminal with:

- **Terrain tiles** (ground, water, walls, paths - rendered as Unicode characters with color)
- **Objects** (trees, rocks, furniture, items)
- **Characters** (NPCs with persistent state)
- **Exits** (connections to adjacent zones)

Zones are generated lazily - they don't exist until the player approaches them. When the player nears the edge of a zone, the AI generates the adjacent zone based on the world seed, current biome, and chronicle context.

### 2.4 Characters as Agents

Every character in the world is a lightweight agent with:

- **Identity**: Name, appearance description, personality traits, backstory
- **Memory**: Their personal conversation history with the player, and awareness of world events relevant to them
- **Goals**: What they want, what they're doing, why they're here
- **Relationships**: How they feel about the player and other characters
- **Behavior**: What they do when the player isn't talking to them (patrol, work, wander, sleep)

Characters are generated by the AI when the world needs them (a town needs a shopkeeper, a forest needs a hermit). Once generated, they persist. Their dialogue is generated by the AI using their identity, memory, and the current world context.

---

## 3. User Experience

### 3.1 Terminal Layout

The game presents a multi-panel terminal interface:

```
┌──────────────────────────────────┬──────────────────┐
│                                  │    Mini-map       │
│         World Viewport           │                   │
│    (tile-based zone rendering    ├──────────────────┤
│     using Unicode art + color)   │  Context Panel   │
│                                  │  (location info,  │
│                                  │   nearby NPCs,    │
│                                  │   time of day)    │
├──────────────────────────────────┴──────────────────┤
│  Narrative Bar / Dialogue / Input                    │
│  (scrollable text area for conversation & narration) │
└──────────────────────────────────────────────────────┘
```

The layout adapts to terminal size using OpenTUI's Flexbox-based layout engine. Minimum supported size: 80x24 characters.

### 3.2 Starting a New World

1. Player launches the game in their terminal: `bun run start` (or a compiled binary)
2. A title screen renders with ASCII art and a text input: "Where would you like to go?"
3. Player types a description (freeform, any length)
4. A loading animation plays in the terminal while the AI generates the initial world
5. The world fades in using terminal color transitions. The player's character appears. A narration line sets the scene in the narrative bar.

### 3.3 Exploration

- **Movement**: Arrow keys or WASD/hjkl (vim keys) to walk around the tile-based world
- **Camera**: The viewport follows the player, with the world extending in all directions
- **World generation**: As the player moves toward unexplored areas, new zones generate ahead of them (preloaded 1-2 zones ahead for seamless experience)
- **Discovery**: New buildings, characters, and landmarks appear as zones generate. The AI considers narrative context when placing them (if you're looking for the blacksmith someone mentioned, they'll appear in a logical direction).

### 3.4 Interaction & Dialogue

When the player approaches a character and presses the interact key:

1. The **narrative bar** expands to show the dialogue interface
2. The character speaks first (greeting, or contextual opening based on what's happening)
3. The player sees **response options** rendered as a selectable list:
   - 2-4 AI-generated contextual dialogue choices
   - An **action option** (e.g., "[Give them the flower]", "[Draw your sword]", "[Run away]")
   - A **freeform input** option where the player can type anything
4. Navigation through options with arrow keys or number keys

The AI generates the character's response based on:
- The character's identity, personality, and memory
- What the player said/did
- Current world context (time of day, recent events, nearby characters)
- The chronicle

### 3.5 Consequences & Events

After each interaction:

1. The AI evaluates whether the conversation should trigger any world changes
2. Changes can be immediate (character gets angry, gives you an item) or deferred (character sends someone after you, spreads a rumor)

On a regular cycle (roughly every 5 minutes of gameplay):

1. The AI reviews the current world state and recent chronicle entries
2. It decides what should happen next:
   - **Environmental**: Weather changes, time of day shifts, seasonal effects (rendered via color palette shifts)
   - **Character**: NPCs move around, new characters arrive, others leave
   - **Narrative**: A messenger arrives with news, a building catches fire, a festival begins
   - **Subtle**: A character's mood shifts, a new item appears in a shop, graffiti appears on a wall
3. The change is applied to the world and recorded in the chronicle

Most changes should be small and atmospheric. Dramatic events should be rare and earned by the narrative buildup.

### 3.6 The Player's Toolkit

The player has a few meta-abilities beyond walking and talking, accessible via keyboard shortcuts:

- **Journal** (`j`): View a player-facing summary of the chronicle (key events, relationships, quests) in a scrollable overlay panel. Auto-generated by the AI.
- **Map** (`m`): A gradually-revealed ASCII map of explored zones
- **Inventory** (`i`): Items collected through exploration and interaction
- **Save/Load** (`Ctrl+S` / `Ctrl+L`): Persistent world saves (local files)
- **Command palette** (`:`): Quick access to game commands

---

## 4. Technical Architecture (High Level)

### 4.1 Stack

| Layer | Technology | Rationale |
|-------|-----------|-----------|
| **Runtime** | Bun (>= 1.2) | Fast TypeScript runtime, built-in SQLite, FFI for native code |
| **TUI Framework** | OpenTUI (@opentui/core) | Flexbox layout via Yoga, native Zig rendering, FrameBuffer for game viewport |
| **Language** | TypeScript | Type safety for complex state management |
| **Package Manager** | Bun workspaces | Native monorepo support, fast installs, isolated linker |
| **AI / LLM** | Claude API (Anthropic) | Primary intelligence layer for all generation |
| **Local Persistence** | SQLite (bun:sqlite) | Built into Bun runtime, fast structured storage, no external dependencies |
| **Cloud Persistence** | Supabase (Postgres + Auth + Storage) | World save sync, user accounts, shared worlds (Phase 2+) |
| **Rendering** | OpenTUI FrameBuffer + Unicode art | Half-block characters for pseudo-pixel rendering, styled text, ANSI colors |

### 4.2 Monorepo Structure

The project is organized as a Bun workspaces monorepo with clear separation of concerns:

```
daydream/
├── package.json              # Root: workspaces + catalogs
├── bun.lock                  # Single lockfile
├── bunfig.toml               # Bun config (isolated linker)
├── tsconfig.base.json        # Shared TS config
├── docs/
│   ├── prd.md
│   └── design.md
├── packages/
│   ├── engine/               # Core game logic (world, characters, events, chronicle)
│   ├── ai/                   # Claude API client, prompts, context management
│   └── renderer/             # Terminal rendering (OpenTUI integration, tile rendering)
└── apps/
    └── game/                 # Main entry point, TUI shell, input routing
```

Package boundaries:
- **`@daydream/engine`**: Pure game logic, no rendering or I/O dependencies. World model, character system, event system, chronicle. Testable in isolation.
- **`@daydream/ai`**: Claude API client, prompt construction, structured output parsing, context budget management. Isolated from game logic for clean mocking/testing.
- **`@daydream/renderer`**: OpenTUI-based terminal rendering. Translates game state into visual output. Owns the tile rendering, dialogue UI, menus, animations.
- **`@daydream/game`** (app): Wires everything together. Entry point, TUI shell, input routing, save/load orchestration.

### 4.3 System Boundaries

```
┌──────────────────────────────────────────────────────┐
│                    Terminal (Bun)                      │
│                                                       │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────┐  │
│  │ Game Viewport│  │ UI Panels    │  │ Overlays   │  │
│  │ (FrameBuffer)│  │ (OpenTUI     │  │ (Journal,  │  │
│  │ - Tile Map   │  │  components) │  │  Map, Inv) │  │
│  │ - Characters │  │ - Dialogue   │  │            │  │
│  │ - Objects    │  │ - Context    │  │            │  │
│  └──────┬───────┘  └──────┬───────┘  └─────┬──────┘  │
│         │                 │               │           │
│  ┌──────┴─────────────────┴───────────────┴────────┐  │
│  │              @daydream/renderer                │  │
│  │  - OpenTUI CliRenderer  - Tile Renderer          │  │
│  │  - UI Components        - Animation System       │  │
│  └──────────────────────────┬──────────────────────┘  │
│                              │                         │
│  ┌───────────────────────────┴─────────────────────┐  │
│  │              @daydream/engine                  │  │
│  │  - Zone Graph    - Character Registry            │  │
│  │  - Chronicle     - Event Queue                   │  │
│  │  - Inventory     - Relationship Graph            │  │
│  │  - World Clock   - Biome System                  │  │
│  └──────────────────────┬──────────────────────────┘  │
│                          │                             │
│  ┌──────────┐  ┌────────┴──────────────────────────┐  │
│  │  @lw/ai  │  │         Persistence Layer          │  │
│  │  Claude   │  │  - SQLite (bun:sqlite)            │  │
│  │  Client   │  │  - File system (world saves)      │  │
│  │  Prompts  │  │  - Supabase (cloud, Phase 2)      │  │
│  └──────────┘  └───────────────────────────────────┘  │
└──────────────────────────────────────────────────────┘
```

### 4.4 AI Integration Points

The AI (Claude) is called at these points:

| Trigger | What It Generates | Latency Budget | Context Needed |
|---------|------------------|----------------|----------------|
| **World creation** | Initial world state, starting zone, characters | 5-10s (one-time) | World seed prompt |
| **Zone generation** | New zone layout, characters, objects | 2-4s (preloaded) | World seed, biome, adjacent zones, chronicle summary |
| **Dialogue response** | Character speech + response options | 1-2s | Character identity, conversation history, recent chronicle |
| **Post-interaction eval** | Event triggers, world changes | 1-2s (background) | Conversation just had, character state, chronicle |
| **Periodic world tick** | Environmental/narrative events | 2-4s (background) | Chronicle summary, active characters, world state |
| **Journal update** | Player-facing narrative summary | 2-3s (on demand) | Full chronicle (compressed) |

---

## 5. Terminal Art System

The terminal is the canvas. Instead of pixel art rendered on HTML5 Canvas, Daydream renders its world using Unicode characters, half-block characters, and ANSI colors through OpenTUI's rendering system.

### 5.1 Rendering Approach

The game viewport uses OpenTUI's `FrameBufferRenderable` for direct cell-by-cell rendering. Each terminal cell can display:

- A Unicode character (from a tile palette)
- A foreground color (24-bit ANSI)
- A background color (24-bit ANSI)
- Text attributes (bold, dim, etc.)

**Half-block pseudo-pixel rendering**: Using the Unicode half-block characters (`▀▄█░▒▓`), each terminal cell can represent 2 vertical "pixels" with independent colors (foreground = top half, background = bottom half). This effectively doubles vertical resolution, giving a 160x48 "pixel" grid in an 80x24 viewport.

### 5.2 Tile Palettes

Each biome defines a palette of Unicode characters and colors for its terrain and objects:

```json
{
  "type": "biome_palette",
  "biome": "enchanted_forest",
  "ground": {
    "chars": ["·", ".", ",", "'"],
    "fg": ["#2d5a27", "#3a7a33", "#1e4a1e"],
    "bg": "#1a3318"
  },
  "trees": {
    "trunk": { "char": "│", "fg": "#5c3a1e" },
    "canopy": { "chars": ["♣", "♠", "⌂"], "fg": ["#228b22", "#2d8b2d", "#1e7a1e"] }
  },
  "water": {
    "chars": ["~", "≈", "∼"],
    "fg": ["#4a8bc7", "#5a9bd7"],
    "bg": "#1a3a5a",
    "animated": true
  },
  "path": {
    "chars": ["░", "·"],
    "fg": "#8b7355",
    "bg": "#5a4a35"
  },
  "special": {
    "mushroom": { "char": "♦", "fg": "#ff4500" },
    "crystal": { "char": "◆", "fg": "#87ceeb" },
    "flower": { "chars": ["✿", "❀", "✾"], "fg": ["#ff69b4", "#da70d6", "#dda0dd"] }
  }
}
```

### 5.3 Character Rendering

Characters are represented as single cells (or 2-cell tall for detail) with a distinctive character and color:

```json
{
  "type": "character_visual",
  "display": {
    "char": "@",
    "fg": "#c9a959",
    "bg": null,
    "bold": true
  },
  "nameplate": "Elara the Merchant",
  "idle_animation": ["@", "☺"],
  "facing": {
    "up": "△",
    "down": "▽",
    "left": "◁",
    "right": "▷"
  }
}
```

The AI generates character visual descriptions that map to display characters and colors, similar to how it selected pixel art palettes in a graphical version.

### 5.4 Building Rendering

Buildings are rendered as multi-cell structures using box-drawing characters and Unicode:

```
╔══════╗
║ Shop ║
║      ║
╚══╤═══╝
   │
```

The AI generates building descriptions that the renderer translates into character art:

```json
{
  "type": "building",
  "footprint": [6, 4],
  "style": "medieval_timber",
  "border_chars": "double",
  "fill_char": " ",
  "door": { "position": "bottom_center", "char": "╤" },
  "sign_text": "The Rusty Anchor",
  "fg": "#c4a882",
  "roof_fg": "#7a6840"
}
```

### 5.5 Atmosphere & Effects

Terminal-native atmospheric effects:

- **Time of day**: Shift the overall color palette (warm at dawn/dusk, cool at night, bright at noon)
- **Weather**: Rain (`│`, `╎`), snow (`*`, `·`), fog (dim everything, add `░`)
- **Lighting**: Torch glow (warm fg colors radiating from sources), moonlight (cool blue tint)
- **Particles**: Floating characters that drift through the viewport (leaves `∞`, sparks `·`, fireflies `*`)

### 5.6 Pre-seeded Tile Library

Ship with a curated set of tile definitions for common biomes and objects:

- ~50 terrain tile sets covering forest, desert, snow, town, dungeon, ocean, mountain, swamp
- ~30 building templates (house, shop, tavern, castle wall, well, bridge)
- ~20 character display presets (villager, guard, merchant, child, animal)
- ~40 object glyphs (trees, rocks, furniture, items, signs)

The LLM can reference these by name and only generate custom definitions when something truly novel is needed.

---

## 6. World Persistence Model

### 6.1 What Gets Saved

| Data | Storage | Format |
|------|---------|--------|
| **World seed** | SQLite + file system | String (original prompt + derived config) |
| **Zone graph** | SQLite | JSON (zone connections, generation params) |
| **Zone tile data** | SQLite | Compressed JSON (tile arrays with character + color data) |
| **Characters** | SQLite | JSON (identity, state, position, memory) |
| **Chronicle** | SQLite | JSON (timestamped event log + compressed summaries) |
| **Player state** | SQLite | JSON (position, inventory, relationships) |
| **AI generation cache** | SQLite | JSON (reusable LLM outputs to avoid redundant calls) |

### 6.2 Save Strategy

- **Auto-save**: Every 60 seconds, write changed state to SQLite
- **Manual save**: `Ctrl+S` triggers an immediate full save
- **Cloud sync**: On explicit save or every 5 minutes, sync to Supabase (Phase 2)
- **World snapshots**: Save files stored as SQLite databases in `~/.daydream/worlds/`
- **Efficient updates**: SQLite transactions batch all changes from the last interval

### 6.3 Chronicle Compression

The raw chronicle grows unboundedly. To keep it manageable:

1. **Raw log**: Last 30 minutes of detailed events (full dialogue, exact actions)
2. **Recent summary**: AI-generated summary of the last 2 hours (key events, relationships changed, narrative threads)
3. **Historical summary**: AI-generated summary of everything before that (major plot points, world-changing events, key character arcs)
4. **Compression runs**: Every 30 minutes, the AI compresses the oldest raw log entries into the recent summary. Every 2 hours, recent summary rolls into historical.

When the AI needs context for generation, it receives: historical summary + recent summary + relevant raw log entries.

---

## 7. Event System

### 7.1 Event Types

| Category | Examples | Frequency |
|----------|----------|-----------|
| **Ambient** | Wind picks up, clouds roll in, a bird flies across | Constant (procedural, no LLM needed) |
| **Minor** | A character moves to a new location, a shop opens/closes, a new item appears | Every 2-5 minutes |
| **Moderate** | A stranger arrives in town, a character starts an argument with another, a building changes | Every 10-20 minutes |
| **Major** | A storm hits, a character disappears, a new area is revealed, a faction conflict erupts | Every 30-60 minutes |
| **Dramatic** | A dragon attacks, the world shifts, a character betrays you, a major revelation | Rare, earned by narrative |

### 7.2 Event Generation

The **World Ticker** runs on a timer:

1. Every 5 minutes: Gather current state (active characters, recent chronicle, player location/actions)
2. Send to AI with the prompt: "Given this world state and recent history, what happens next? Consider the current narrative threads and tone. Most of the time, small atmospheric changes are appropriate. Only trigger major events if the narrative has built toward them."
3. AI returns a structured event:
   ```json
   {
     "events": [
       {
         "type": "minor",
         "description": "The old fisherman walks to the dock and sits down",
         "affects": ["character:old_fisherman"],
         "changes": {
           "old_fisherman.position": {"zone": "docks", "x": 12, "y": 8},
           "old_fisherman.state": "sitting_fishing"
         }
       }
     ],
     "narrative_note": "Building tension around the missing fish - fisherman is worried but trying to act normal"
   }
   ```
4. Events are applied to the world state and recorded in the chronicle

### 7.3 Conversation-Triggered Events

After each conversation ends:

1. AI evaluates: "Given this conversation and the world context, should anything change?"
2. Possible outcomes:
   - **Nothing**: Most conversations don't trigger events
   - **Character state change**: The character's mood, goals, or relationship with the player shifts
   - **Deferred event**: Something will happen later (the character tells someone else what you said)
   - **Immediate event**: Something happens right now (the character gives you something, attacks you, runs away)
   - **Quest hook**: A narrative thread is established that the AI will develop over time

---

## 8. Dialogue System (Detailed)

### 8.1 Dialogue Flow

```
Player approaches character → [interact key: e/Enter]
         |
         v
Narrative bar expands to dialogue mode
Character greets player (AI-generated, streamed character-by-character)
         |
         v
Player sees response options (selectable list in narrative bar):
  [1] Contextual dialogue choice
  [2] Contextual dialogue choice
  [3] An action (physical, not verbal)
  [>] Type your own... (freeform input)
         |
         v
Player selects (number key or arrow+enter) → sent to AI with full context
         |
         v
Character responds (AI-generated, streamed)
         |
         v
Loop continues until:
  - Player presses Escape to walk away
  - Character ends conversation
  - An event interrupts
         |
         v
Post-conversation evaluation (background)
  → Chronicle updated
  → Event triggers checked
```

### 8.2 Response Option Generation

The AI generates response options that are:

- **Contextually relevant** to what the character just said
- **Varied in approach** (friendly, confrontational, curious, evasive)
- **Sometimes include actions** ("[Offer to help carry the crates]", "[Pocket the coin when they're not looking]", "[Hug them]")
- **Sometimes include humor/creativity** ("[Do a little dance]", "[Pretend you don't speak their language]")

The freeform option lets players go completely off-script, which the AI handles by treating their input as dialogue or action and generating an appropriate response.

### 8.3 Response Options Schema

```json
{
  "character_speech": "The merchant eyes you suspiciously. 'You're not from around here, are you? We don't get many strangers since... well, since the incident.'",
  "options": [
    {
      "type": "dialogue",
      "text": "What incident? Tell me more.",
      "tone": "curious"
    },
    {
      "type": "dialogue",
      "text": "I'm just passing through. No trouble.",
      "tone": "dismissive"
    },
    {
      "type": "action",
      "text": "[Place a gold coin on the counter]",
      "tone": "persuasive"
    },
    {
      "type": "action",
      "text": "[Lean in closer and whisper]",
      "tone": "conspiratorial"
    }
  ],
  "freeform_enabled": true
}
```

---

## 9. MVP Scope

The full vision is ambitious. The MVP should prove the core loop works: **prompt → world → explore → talk → events → persistence**.

### 9.1 MVP Features (Phase 1)

**World Generation**
- Single-zone world generation from a prompt (one screen, expandable later)
- Basic biome rendering (ground tiles, a few buildings, trees - all Unicode art)
- 3-5 characters placed in the starting zone

**TUI Shell**
- OpenTUI-based terminal interface with game viewport + narrative bar
- Responsive layout that adapts to terminal size
- Keyboard input handling (movement, interaction, menus)

**Exploration**
- Arrow key / WASD / hjkl movement on a tile grid
- Collision with buildings and objects
- Viewport following the player

**Dialogue**
- Walk up to a character and press interact
- AI-generated dialogue with 2-3 response options + freeform
- Character memory (remembers what you said earlier in the session)
- Streamed text display (typewriter effect)

**Events**
- Post-conversation event evaluation
- A simple world tick every 5 minutes (minor changes only)
- Chronicle logging (internal, not yet player-facing)

**Visuals**
- Pre-built tile library for common biomes and entities
- Character display with color and facing direction
- Basic ambient animation (water shimmer, flickering torches)

**Persistence**
- SQLite local save (auto-save + manual)
- Single save slot
- Save files in `~/.daydream/worlds/`

### 9.2 Phase 2

- Multi-zone world with lazy generation
- Custom tile generation (LLM → unique Unicode art definitions)
- Player journal (AI-summarized chronicle, rendered with OpenTUI's Markdown component)
- Richer event system (moderate + major events)
- Multiple save slots
- ASCII map of explored zones
- Cloud save via Supabase

### 9.3 Phase 3

- Building interiors
- Inventory system
- Character-to-character interactions (NPCs talk to each other)
- Procedural ambient sound (via terminal bell / system audio if available)
- World sharing (export seed + chronicle for others to explore)
- Compiled binary distribution (Bun's single-file executable)
- Multiplayer foundations

---

## 10. Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| **LLM latency** | Breaks immersion during dialogue/generation | Preload zones ahead of player. Stream dialogue. Queue events in background. Show animated loading indicators. |
| **LLM cost** | Could be expensive at scale | Cache aggressively. Use compressed context. Batch requests where possible. Use lighter models for simple tasks. |
| **Context window limits** | Chronicle grows unboundedly | Compression strategy (Section 6.3). Hierarchical summaries. Relevance filtering. |
| **Terminal rendering limitations** | Less visual richness than graphical game | Lean into the aesthetic - roguelike charm. Half-block pseudo-pixels for detail. Rich color palettes. Focus on narrative over visuals. |
| **Terminal compatibility** | Different terminals render Unicode/colors differently | Target modern terminals (iTerm2, WezTerm, Ghostty, Windows Terminal, Kitty). Test with OpenTUI's rendering engine. Graceful fallback for limited terminals. |
| **World coherence** | AI might generate contradictory content | Strong world state tracking. Include recent context in every generation call. Periodic coherence checks. |
| **Player freedom vs. structure** | Too freeform = no sense of purpose; too structured = not creative enough | Let the AI balance this. Narrative threads give direction without forcing. Player actions always have consequences. |
| **Save file size** | Worlds with many zones + full chronicle could get large | Compress data. Summarize chronicle. SQLite handles large datasets efficiently. Only persist explored zones. |
| **Bun + OpenTUI maturity** | Both are relatively young, APIs may change | Pin dependency versions. Abstract OpenTUI behind our own renderer layer. Monitor upstream releases. |

---

## 11. Success Criteria

The game is successful if:

1. A player can type a world prompt and get a coherent, explorable world within 10 seconds
2. Conversations feel natural and characters feel like they have real personalities
3. Player choices visibly affect the world (characters react differently, events change)
4. A player can exit and come back and the world remembers everything
5. Two players given the same prompt get meaningfully different worlds based on their choices
6. The world feels alive even when the player isn't interacting (events happen, characters move)
7. The terminal aesthetic is evocative and charming - players appreciate the roguelike visual style
8. It's genuinely fun and surprising - players want to keep exploring to see what happens next

---

## 12. Open Questions

1. **Animation depth**: How much terminal animation do we want? Water shimmer, character idle cycles, weather particles? Each adds CPU overhead for re-rendering.
2. **Combat**: Should there be a combat system, or is this purely narrative/social? If combat, turn-based or real-time?
3. **Crafting/building**: Can the player build or modify the world physically, or only through narrative actions?
4. **Sound**: Can we integrate system audio for ambient sound/music, or is this a silent experience?
5. **Distribution**: Should we ship as a Bun script, a compiled binary (Bun single-file executable), or both?
6. **Monetization**: If this ever launches publicly, how? API costs need to be covered somehow.
7. **React vs SolidJS vs Imperative**: OpenTUI supports all three. Which API style should the renderer package use? (Recommendation: start with imperative/core API for maximum control, consider SolidJS for complex UI panels.)
